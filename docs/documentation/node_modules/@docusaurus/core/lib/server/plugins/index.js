"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@docusaurus/utils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const init_1 = require("./init");
function sortConfig(routeConfigs) {
    // Sort the route config. This ensures that route with nested
    // routes is always placed last.
    routeConfigs.sort((a, b) => {
        if (a.routes && !b.routes) {
            return 1;
        }
        if (!a.routes && b.routes) {
            return -1;
        }
        // Higher priority get placed first.
        if (a.priority || b.priority) {
            const priorityA = a.priority || 0;
            const priorityB = b.priority || 0;
            const score = priorityA > priorityB ? -1 : priorityB > priorityA ? 1 : 0;
            if (score !== 0) {
                return score;
            }
        }
        return a.path > b.path ? 1 : b.path > a.path ? -1 : 0;
    });
    routeConfigs.forEach((routeConfig) => {
        var _a;
        (_a = routeConfig.routes) === null || _a === void 0 ? void 0 : _a.sort((a, b) => {
            return a.path > b.path ? 1 : b.path > a.path ? -1 : 0;
        });
    });
}
exports.sortConfig = sortConfig;
async function loadPlugins({ pluginConfigs, context, }) {
    // 1. Plugin Lifecycle - Initialization/Constructor.
    const plugins = init_1.initPlugins({ pluginConfigs, context });
    // 2. Plugin Lifecycle - loadContent.
    // Currently plugins run lifecycle methods in parallel and are not order-dependent.
    // We could change this in future if there are plugins which need to
    // run in certain order or depend on others for data.
    const pluginsLoadedContent = await Promise.all(plugins.map(async (plugin) => {
        if (!plugin.loadContent) {
            return null;
        }
        return await plugin.loadContent();
    }));
    // 3. Plugin Lifecycle - contentLoaded.
    const pluginsRouteConfigs = [];
    await Promise.all(plugins.map(async (plugin, index) => {
        if (!plugin.contentLoaded) {
            return;
        }
        const pluginContentDir = path_1.default.join(context.generatedFilesDir, plugin.name);
        const actions = {
            addRoute: (config) => pluginsRouteConfigs.push(config),
            createData: async (name, content) => {
                const modulePath = path_1.default.join(pluginContentDir, name);
                await fs_extra_1.default.ensureDir(path_1.default.dirname(modulePath));
                await utils_1.generate(pluginContentDir, name, content);
                return modulePath;
            },
        };
        await plugin.contentLoaded({
            content: pluginsLoadedContent[index],
            actions,
        });
    }));
    // 4. Plugin Lifecycle - routesLoaded.
    // Currently plugins run lifecycle methods in parallel and are not order-dependent.
    // We could change this in future if there are plugins which need to
    // run in certain order or depend on others for data.
    await Promise.all(plugins.map(async (plugin) => {
        if (!plugin.routesLoaded) {
            return null;
        }
        return await plugin.routesLoaded(pluginsRouteConfigs);
    }));
    // Sort the route config. This ensures that route with nested
    // routes are always placed last.
    sortConfig(pluginsRouteConfigs);
    return {
        plugins,
        pluginsRouteConfigs,
    };
}
exports.loadPlugins = loadPlugins;
