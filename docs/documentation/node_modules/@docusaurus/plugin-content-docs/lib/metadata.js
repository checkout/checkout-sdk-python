"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const utils_1 = require("@docusaurus/utils");
const lastUpdate_1 = __importDefault(require("./lastUpdate"));
function removeVersionPrefix(str, version) {
    return str.replace(new RegExp(`^version-${version}/`), '');
}
function inferVersion(dirName, versioning) {
    if (!versioning.enabled) {
        return undefined;
    }
    if (/^version-/.test(dirName)) {
        const inferredVersion = dirName
            .split('/', 1)
            .shift()
            .replace(/^version-/, '');
        if (inferredVersion && versioning.versions.includes(inferredVersion)) {
            return inferredVersion;
        }
        else {
            throw new Error(`Can't infer version from folder=${dirName}
Expected versions:
- ${versioning.versions.join('- ')}`);
        }
    }
    else {
        return 'next';
    }
}
async function lastUpdated(filePath, options) {
    const { showLastUpdateAuthor, showLastUpdateTime } = options;
    if (showLastUpdateAuthor || showLastUpdateTime) {
        // Use fake data in dev for faster development.
        const fileLastUpdateData = process.env.NODE_ENV === 'production'
            ? await lastUpdate_1.default(filePath)
            : {
                author: 'Author',
                timestamp: 1539502055,
            };
        if (fileLastUpdateData) {
            const { author, timestamp } = fileLastUpdateData;
            return {
                lastUpdatedAt: showLastUpdateTime ? timestamp : undefined,
                lastUpdatedBy: showLastUpdateAuthor ? author : undefined,
            };
        }
    }
    return {};
}
async function processMetadata({ source, refDir, context, options, env, }) {
    const { routeBasePath, editUrl, homePageId } = options;
    const { siteDir, baseUrl } = context;
    const { versioning } = env;
    const filePath = path_1.default.join(refDir, source);
    const fileMarkdownPromise = utils_1.parseMarkdownFile(filePath);
    const lastUpdatedPromise = lastUpdated(filePath, options);
    const dirName = path_1.default.dirname(source);
    const version = inferVersion(dirName, versioning);
    // The version portion of the url path. Eg: 'next', '1.0.0', and ''.
    const versionPath = version && version !== versioning.latestVersion ? version : '';
    const relativePath = path_1.default.relative(siteDir, filePath);
    const docsEditUrl = utils_1.getEditUrl(relativePath, editUrl);
    const { frontMatter = {}, excerpt } = await fileMarkdownPromise;
    const { sidebar_label, custom_edit_url } = frontMatter;
    // Default base id is the file name.
    const baseID = frontMatter.id || path_1.default.basename(source, path_1.default.extname(source));
    if (baseID.includes('/')) {
        throw new Error('Document id cannot include "/".');
    }
    const id = dirName !== '.' ? `${dirName}/${baseID}` : baseID;
    const idWithoutVersion = version ? removeVersionPrefix(id, version) : id;
    const isDocsHomePage = idWithoutVersion === homePageId;
    if (frontMatter.slug && isDocsHomePage) {
        throw new Error(`The docs homepage (homePageId=${homePageId}) is not allowed to have a frontmatter slug=${frontMatter.slug} => you have to chooser either homePageId or slug, not both`);
    }
    const baseSlug = frontMatter.slug || baseID;
    if (baseSlug.includes('/')) {
        throw new Error('Document slug cannot include "/".');
    }
    const slug = dirName !== '.' ? `${dirName}/${baseSlug}` : baseSlug;
    // Default title is the id.
    const title = frontMatter.title || baseID;
    const description = frontMatter.description || excerpt;
    // The last portion of the url path. Eg: 'foo/bar', 'bar'.
    let routePath;
    if (isDocsHomePage) {
        // TODO can we remove this trailing / ?
        // Seems it's not that easy...
        // Related to https://github.com/facebook/docusaurus/issues/2917
        routePath = '/';
    }
    else {
        routePath =
            version && version !== 'next' ? removeVersionPrefix(slug, version) : slug;
    }
    const permalink = utils_1.normalizeUrl([
        baseUrl,
        routeBasePath,
        versionPath,
        routePath,
    ]);
    const { lastUpdatedAt, lastUpdatedBy } = await lastUpdatedPromise;
    // Assign all of object properties during instantiation (if possible) for
    // NodeJS optimization.
    // Adding properties to object after instantiation will cause hidden
    // class transitions.
    const metadata = {
        id,
        isDocsHomePage,
        title,
        description,
        source: utils_1.aliasedSitePath(filePath, siteDir),
        permalink,
        editUrl: custom_edit_url !== undefined ? custom_edit_url : docsEditUrl,
        version,
        lastUpdatedBy,
        lastUpdatedAt,
        sidebar_label,
    };
    return metadata;
}
exports.default = processMetadata;
